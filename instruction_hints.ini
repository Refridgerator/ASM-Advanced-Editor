;; part of Intel® 64 and IA-32 Architectures Software Developer’s Manual
;; 
[5.1 GENERAL-PURPOSE INSTRUCTIONS]
;;The general-purpose instructions preform basic data movement, arithmetic, logic, program flow, and string opera-
;;tions that programmers commonly use to write application and system software to run on Intel 64 and IA-32 
;;processors. They operate on data contained in memory, in the general-purpose registers (EAX, EBX, ECX, EDX, 
;;EDI, ESI, EBP, and ESP) and in the EFLAGS register. They also operate on address information contained in 
;;memory, the general-purpose registers, and the segment registers (CS, DS, SS, ES, FS, and GS). 

[5.1.1 Data Transfer Instructions]
;;The data transfer instructions move data between memory and the general-purpose and segment registers. They also perform specific operations such as conditional moves, stack access, and data conversion.
MOV = пересылка
CMOVE / CMOVZ =  пересылка если равно / пересылка если ноль
CMOVNE / CMOVNZ = пересылка если не равно / пересылка если не ноль
CMOVA / CMOVNBE = пересылка если выше / пересылка если не ниже или равно
CMOVAE / CMOVNB = пересылка если выше или равно / пересылка если не ниже
CMOVB / CMOVNAE = пересылка если ниже / пересылка если не выше или равно
CMOVBE / CMOVNA = пересылка если ниже или равно / пересылка если не выше
CMOVG / CMOVNLE = пересылка если больше / пересылка если не меньше или равно
CMOVGE / CMOVNL = пересылка если больше или равно / пересылка если не меньше
CMOVL / CMOVNGE = пересылка если меньше / пересылка если не больше или равно
CMOVLE / CMOVNG = пересылка если меньше или равно / пересылка если не больше
CMOVC = пересылка если перенос (carry)
CMOVNC = пересылка если нет переноса (не carry)
CMOVO = пересылка если переполнение (overflow)
CMOVNO = пересылка если нет переполнения (не overflow)
CMOVS = пересылка если отрицательное число (sign)
CMOVNS = пересылка если положительное число (не sign)
CMOVP / CMOVPE = пересылка если parity / пересылка если четный паритет (parity)
CMOVNP / CMOVPO = пересылка если не parity / пересылка если нечетный паритет (не parity)
XCHG = обмен значениями между операндами
BSWAP = меняет порядок байт на противоположный
XADD = меняет операнды местами и в 1-ый записывает сумму
CMPXCHG = сравнивает 1-ый операнд с (E)AX и если равны, копирует в него 2-ый операнд.\nИначе копирует 1-ый операнд в (E)AX.
CMPXCHG8B = сравнивает операнд с EDX:EAX и если равны, копирует в него ECX:EBX.\nИначе копирует операнд в EDX:EAX.
PUSH = положить регистр в стек
POP = извлечь регистр из стека
<<<<<<< HEAD
PUSHA / PUSHAD = положить все регистры общего назначения в стек
POPA / POPAD = извлечь все регистры общего назначения из стека
=======
PUSHA / PUSHAD =  положить в стек все регистры общего назначения
POPA / POPAD = извлечь из стека все регистры общего назначения
>>>>>>> 605a8b914f481e556ec436778e701bc7efd13855
CWD / CDQ = знаковое преобразование AX в DX:AX / знаковое преобразование EAX в EDX:EAX
CBW / CWDE = знаковое преобразование AL в AX / знаковое преобразование AX в EAX
MOVSX = пересылка со знаковым расширением
MOVZX = пересылка с нулевым расширением

[5.1.2 Binary Arithmetic Instructions]
;;The binary arithmetic instructions perform basic binary integer computations on byte, word, and doubleword inte-gers located in memory and / or the general purpose registers.
ADCX = беззнаковое сложение с учётом переноса (carry)
ADOX = беззнаковое сложение с учётом переполнения (overflow)
ADD = сложение
ADC = сложение с учётом переноса (carry)
SUB = вычитание
SBB = вычитание с заёмом (carry)
IMUL = знаковое умножение
MUL = беззнаковое умножение
IDIV = знаковое деление
DIV = беззнаковое деление
INC = увеличить на 1
DEC = уменьшить на 1
NEG = изменить знак на противоположный
CMP = сравнить

[5.1.3 Decimal Arithmetic Instructions]
;;The decimal arithmetic instructions perform decimal arithmetic on binary coded decimal (BCD) data.
DAA = Десятичная коррекция после сложения
DAS = Десятичная коррекция после вычитания
AAA = ASCII-коррекция после сложения
AAS = ASCII-коррекция после вычитания
AAM = ASCII-коррекция после умножения
AAD = ASCII-коррекция перед делением

[5.1.4 Logical Instructions]
;;The logical instructions perform basic AND, OR, XOR, and NOT logical operations on byte, word, and doubleword values
AND = логическое И (конъюнкция)
OR = логическое ИЛИ (дизъюнкция)
XOR = исключающее ИЛИ
NOT = логическое НЕ (инверсия бит)

[5.1.5 Shift and Rotate Instructions]
;;The shift and rotate instructions shift and rotate the bits in word and doubleword operands.
SAR = арифметический сдвиг вправо - старший бит не меняется
SHR = логический сдвиг вправо - старший бит приравнивается 0
SAL = арифметический сдвиг влево - младший бит приравнивается 0
SHL = логический сдвиг влево - младший бит приравнивается 0
SHRD = сдвиг двойного слова вправо
SHLD = сдвиг двойного слова влево
ROR = циклический сдвиг вправо
ROL = циклический сдвиг влево
RCR = циклический сдвиг вправо через флаг переноса (carry)
RCL = циклический сдвиг влево через флаг переноса (carry)

[5.1.6 Bit and Byte Instructions]
;;Bit instructions test and modify individual bits in word and doubleword operands. Byte instructions set the value of a byte operand to indicate the status of flags in the EFLAGS register.
BT = извлечение бита в флаг carry
BTS = извлечение бита в флаг carry и установка этого бита в единицу
BTR = извлечение бита в флаг carry и установка этого бита в ноль
BTC = извлечение бита в флаг carry и его инверсия
BSF = поиск позиции единичного бита, начиная с бита 0
BSR = поиск позиции единичного бита, начиная с бита 15/31
SETE / SETZ = установка бита, если равно / установка бита, если ноль
SETNE / SETNZ = установка бита, если не равно / установка бита, если не ноль
SETA / SETNBE = установка бита, если выше / установка бита, если не ниже или равно
SETAE / SETNB = установка бита, если выше или равно / установка бита, если не ниже
SETB / SETNAE = установка бита, если ниже / установка бита, если не выше или равно
SETBE / SETNA = установка бита, если ниже или равно / установка бита, если не выше
SETG / SETNLE = установка бита, если больше / установка бита, если не меньше или равно
SETGE / SETNL = установка бита, если больше или равно / установка бита, если не меньше
SETL / SETNGE = установка бита, если меньше / установка бита, если не больше или равно
SETLE / SETNG = установка бита, если меньше или равно / установка бита, если не больше
SETC =  установка бита, если перенос (carry)
SETNC = установка бита, если нет переноса (не carry)
SETS = установка бита, если число отрицательное (sign)
SETNS = установка бита, если число положительное (не sign)
SETO = установка бита, если переполнение (overflow)
SETNO = установка бита, если нет переполнения (не overflow)
SETPE / SETP = установка бита, если четный паритет (parity) / установка бита, если parity
SETPO / SETNP = установка бита, если нечетный паритет (не parity) / установка бита, если не parity
TEST = логическое сравнение по И (AND)
CRC32 = подсчёт CRC32
POPCNT = подсчёт количества единичных бит

[5.1.7 Control Transfer Instructions]
;;The control transfer instructions provide jump, conditional jump, loop, and call and return operations to control program flow
JMP = переход
JE / JZ = переход если равно / переход если ноль
JNE / JNZ = переход если не равно / переход если не ноль
JA / JNBE = переход если выше / переход если не ниже или равно
JAE / JNB = переход если выше или равно / переход если не ниже
JB / JNAE = переход если ниже / переход если не выше или равно
JBE / JNA = переход если ниже или равно / переход если не выше
JG / JNLE = переход если больше / переход если не меньше или равно
JGE / JNL = переход если больше или равно / переход если не меньше
JL / JNGE = переход если меньше / переход если не больше или равно
JLE / JNG = переход если меньше или равно / переход если не больше
JC = переход если перенос (carry)
JNC = переход если нет переноса (не carry)
JO = переход если переполнение (overflow)
JNO = переход если нет переполнения (не overflow)
JS = переход если число отрицательное (sign)
JNS = переход если число положительное (не sign)
JPO / JNP = переход если нечетный паритет (не parity) / переход если не parity
JPE / JP = переход если четный паритет (parity) / переход если parity
JCXZ / JECXZ = переход если CX=0 / переход если ECX=0
LOOP = цикл со счетчиком в регистре (E)CX 
LOOPZ / LOOPE = цикл со счетчиком в регистре (E)CX и при zf=1 (ноль)
LOOPNZ / LOOPNE = цикл со счетчиком в регистре (E)CX и при zf=0 (не ноль)
CALL = вызов процедуры
RET = возврат из процедуры
IRET = возврат из прерывания
INT = прерывание
INTO = прерывание при overflow
BOUND = проверяет вхождение индекса в диапазон 
ENTER = вход в high-level процедуру
LEAVE = выход из high-level процедуры

[5.1.8 String Instructions]
;;The string instructions operate on strings of bytes, allowing them to be moved to and from memory.
MOVS / MOVSB = копировать строку / копировать строку byte
MOVSW = копировать строку word 
MOVSD = копировать строку doubleword

CMPS / CMPSB = сравнить строку / сравнить строку byte
CMPSW = сравнить строку word
CMPSD = сравнить строку doubleword

SCAS / SCASB = поиск значения в строке / поиск значения в строке byte
SCASW = поиск значения в строке word
SCASD = поиск значения в строке doubleword

LODS / LODSB = загрузка значения из строки / загрузка из строки byte
LODSW = загрузка значения из строки word
LODSD = загрузка значения из строки doubleword

STOS / STOSB = сохранение значения в строке / сохранение значения в строке byte
STOSW = сохранение значения в строке word
STOSD = сохранение значения в строке doubleword

REP = повтор пока ECX не ноль
REPE / REPZ = повтор пока равно / повтор пока ноль
REPNE / REPNZ = повтор пока не равно / повтор пока не ноль

[5.1.9 I / O Instructions]
;;These instructions move data between the processor’s I / O ports and a register or memory.
IN = ввод значения из порта ввода-вывода
OUT = вывод значения в порт ввода-вывода
INS / INSB = ввод цепочки значений из порта ввода-вывода / ввод цепочки byte из порта ввода-вывода
INSW = ввод цепочки word из порта ввода-вывода
INSD = ввод цепочки doubleword из порта ввода-вывода
OUTS / OUTSB = вывод цепочки значений в порт ввода-вывода / вывод цепочки byte string в порт ввода-вывода
OUTSW = вывод цепочки word в порт ввода-вывода
OUTSD = вывод цепочки doubleword в порт ввода-вывода

[5.1.10 Enter and Leave Instructions]
;;These instructions provide machine-language support for procedure calls in block-structured languages.
;;ENTER = High-level procedure entry
;;LEAVE = High-level procedure exit

[5.1.11 Flag Control (EFLAG) Instructions]
;;The flag control instructions operate on the flags in the EFLAGS register.
STC = установить флаг переноса (carry)
CLC = сбросить флаг переноса (carry)
CMC = инвертирование флага переноса (carry)
CLD = бросить флаг направления (direction)
STD = установить флаг направления (direction)
LAHF = загрузить flags в AH регистр
SAHF = восстановить flags из AH регистра
PUSHF / PUSHFD = положить EFLAGS в стек
POPF / POPFD = извлечь EFLAGS из стека
STI = установить флаг прерывания (interrupt)
CLI = сбросить tфлаг прерывания (interrupt)

[5.1.12 Segment Register Instructions]
;;The segment register instructions allow far pointers (segment addresses) to be loaded into the segment registers.
LDS = загрузка сегментного регистра DS указателем из памяти
LES = загрузка сегментного регистра ES указателем из памяти
LFS = загрузка сегментного регистра FS указателем из памяти
LGS = загрузка сегментного регистра GS указателем из памяти
LSS = загрузка сегментного регистра SS указателем из памяти

[5.1.13 Miscellaneous Instructions]
;;The miscellaneous instructions provide such functions as loading an effective address, executing a “no-operation,” and retrieving processor identification information.
LEA = загрузка эффективного адреса
NOP = нет операции
UD2 = неопределённая инструкция
XLAT / XLATB = подмена байта в регистре al байтом из последовательности (таблицы) байтов в памяти
CPUID = информация о процессоре
MOVBE1 = копировать после изменения порядка байт
PREFETCHW = выбрать из памяти в кеш строку данных с возможностью их последующего изменения 
PREFETCHWT1 = Prefetch hint T1 with intent to write

[5.1.14 Random Number Generator Instructions]
RDRAND / RDSEED = получить случайное число

[5.1.15 BMI1, BMI2]
ANDN = логическое И с инвертированным 2-м операндом
BEXTR = извлекает последовательность бит
BLSI = извлекает наименьший установленный бит из операнда-источника и устанавливает соответствующий бит в операнде назначения
BLSMSK = устанавливает все нижние биты в 1 в операнде назначения вплоть до первого установленного в операнде-источнике
BLSR = сбрасывает наименьший установленный бит
BZHI = обнуление верхних бит с определённой позиции
LZCNT = подсчёт количества начальных нулевых бит
MULX = беззнаковое умножение без влияния на арифметические флаги
PDEP = паралельное распределение бит с использованием маски
PEXT = паралельное извлечение бит с использованием маски
RORX = циклический сдвиг вправо без влияния на арифметические флаги
SARX = арифметический сдвиг вправо
SHLX = логический сдвиг влево
SHRX = логический сдвиг вправо
TZCNT = подсчёт количества конечных нулевых бит

[5.2 X87 FPU INSTRUCTIONS]
;;The x87 FPU instructions are executed by the processor’s x87 FPU. These instructions operate on floating-point, integer, and binary-coded decimal (BCD) operands.

[5.2.1 x87 FPU Data Transfer Instructions]
;;The data transfer instructions move floating-point, integer, and BCD values between memory and the x87 FPU registers. They also perform conditional move operations on floating-point operands.
FLD = загрузить число с плавающей точкой
FST = сохранить число с плавающей точкой
FSTP = сохранить число с плавающей точкой с извлечением
FILD = загрузить целое число
FIST = сохранить целое число
FISTP = сохранить целое число с извлечением
FBLD = загрузить двоично-десятичное число
FBSTP = сохранить двоично-десятичное число с извлечением
FXCH = обменять значения регистров
FCMOVE = пересылка если равно
FCMOVNE =  пересылка если не равно
FCMOVB =  пересылка если ниже
FCMOVBE =  пересылка если ниже или равно
FCMOVNB =  пересылка если не ниже
FCMOVNBE =  пересылка если не ниже или равно
FCMOVU =  пересылка если не упорядочены
FCMOVNU =  пересылка если упорядочены

[5.2.2 x87 FPU Basic Arithmetic Instructions]
;;The basic arithmetic instructions perform basic arithmetic operations on floating-point and integer operands.
FADD = сложение чисел с плавающей точкой
FADDP = сложение чисел с плавающей точкой с извлечением
FIADD = сложение целых чисел
FSUB = вычитание чисел с плавающей точкой
FSUBP = вычитание чисел с плавающей точкой с извлечением
FISUB = вычитание целых чисел
FSUBR = реверсивное вычитание чисел с плавающей точкой
FSUBRP = реверсивное вычитание чисел с плавающей точкой с извлечением
FISUBR = реверсивное вычитание целых чисел
FMUL = умножение чисел с плавающей точкой
FMULP = умножение чисел с плавающей точкой с извлечением
FIMUL = умножение целых чисел
FDIV = деление чисел с плавающей точкой
FDIVP = деление чисел с плавающей точкой с извлечением
FIDIV = деление целых чисел
FDIVR = реверсивное деление чисел с плавающей точкой
FDIVRP = реверсивное деление чисел с плавающей точкой с извлечением
FIDIVR = реверсивное деление целых чисел
FPREM = частичный остаток
FPREM1 = частичный остаток по стандарту IEEE-754
FABS = абсолютное значение
FCHS = изменение знака на противоположное
FRNDINT = округление к целому числу
FSCALE = масштабирование степенью двойки
FSQRT = квадратный корень
FXTRACT = разложить на мантиссу и экспоненту

[5.2.3 x87 FPU Comparison Instructions]
;;The compare instructions examine or compare floating-point or целых чисел operands.
FCOM = сравнение чисел с плавающей точкой
FCOMP = сравнение чисел с плавающей точкой с извлечением
FCOMPP = сравнение чисел с плавающей точкой с двойным извлечением
FUCOM = неупорядоченное сравнение чисел с плавающей точкой
FUCOMP = неупорядоченное сравнение чисел с плавающей точкой с извлечением
FUCOMPP = неупорядоченное сравнение чисел с плавающей точкой с двойным извлечением
FICOM = сравнение целых чисел
FICOMP = сравнение целых чисел с извлечением
FCOMI = сравнение чисел с плавающей точкой и установка EFLAGS
FUCOMI = неупорядоченное сравнение чисел с плавающей точкой и установка EFLAGS
FCOMIP = сравнение чисел с плавающей точкой, установка EFLAGS, с извлечением
FUCOMIP = неупорядоченное сравнение чисел с плавающей точкой, установка EFLAGS, с извлечением
FTST = сравнение с нулём
FXAM = проверка числа

[5.2.4 x87 FPU Transcendental Instructions]
;;The transcendental instructions perform basic trigonometric and logarithmic operations on floating-point operands.
FSIN = синус
FCOS = косинус
FSINCOS = синус и косинус
FPTAN = тангенс
FPATAN = арктангенс
F2XM1 = 2^x − 1
FYL2X = y∗log2(x)
FYL2XP1 = y∗log2(x+1)

[5.2.5 x87 FPU Load Constants Instructions]
;;The load constants instructions load common constants, such as π, into the x87 floating-point registers.
FLD1 = загрузить +1.0
FLDZ = загрузить +0.0
FLDPI = загрузить pi
FLDL2E = загрузить log2(e)
FLDLN2 = загрузить loge(2)
FLDL2T = загрузить log2(10)
FLDLG2 = загрузить log10(2)

[5.2.6 x87 FPU Control Instructions]
;;The x87 FPU control instructions operate on the x87 FPU register stack and save and restore the x87 FPU state.
FINCSTP = увеличить указатель стека FPU
FDECSTP = уменьшить указатель стека FPU
FFREE = пометить регистр как пустой
FINIT = инициализация FPU после проверки отложенных исключений
FNINIT = инициализация FPU без проверки отложенных исключений
FCLEX = сбросить флаги исключений после проверки отложенных исключений
FNCLEX = сбросить флаги исключений без проверки отложенных исключений
FSTCW = сохранить FPU control word после проверки отложенных исключений
FNSTCW = сохранить FPU control word без проверки отложенных исключений
FLDCW = загрузить FPU control word
FSTENV = сохранить FPU окружение после проверки отложенных исключений
FNSTENV = сохранить FPU окружение без проверки отложенных исключений
FLDENV = загрузить FPU окружение
Fсохранить = сохранить FPU состояние после проверки отложенных исключений
FNсохранить = сохранить FPU состояние без проверки отложенных исключений
FRSTOR = восстановить FPU состояние
FSTSW = сохранить FPU status word после проверки отложенных исключений
FNSTSW = сохранить FPU status word без проверки отложенных исключений
WAIT / FWAIT = синхронизация между CPU/FPU
FNOP = нет операции

[5.3 X87 FPU AND SIMD STATE MANAGEMENT INSTRUCTIONS]
;;Two state management instructions were introduced into the IA-32 architecture with the Pentium II processor family:
FXSAVE = сохранить x87, FPU и SIMD состояние
FXRSTOR = восстановить x87, FPU и SIMD состояние
;;Initially, these instructions operated only on the x87 FPU (and MMX) registers to perform a fast save and restore, 
;;respectively, of the x87 FPU and MMX state. With the introduction of SSE extensions in the Pentium III processor 
;;family, these instructions were expanded to also save and restore the state of the XMM and MXCSR registers. Intel 
;;64 architecture also supports these instructions.

[5.19 64-BIT MODE INSTRUCTIONS]
;;The following instructions are introduced in 64-bit mode. This mode is a sub-mode of IA-32e mode.
CDQE = преобразовать doubleword в quadword
CMPSQ = сравнить строки
CMPXCHG16B = сравнить RDX:RAX с m128
LODSQ = загрузить qword по адресу (R)SI в RAX
MOVSQ = копировать qword из адреса (R)SI в (R)DI
;;MOVZX (64-bits) = Move bytes / words to doublewords / quadwords, zero-extension
STOSQ = сохранить RAX по адресу RDI
SWAPGS = обмен текущего значения регистра GS с MSR по адресу C0000102H
SYSCALL = вызов системной процедуры
SYSRET = выход из системной процедуры

;; #######################################################################################################################
;; MMX и SSE1/2/3/4 пока что не переведены
;; #######################################################################################################################
[5.4 MMX™ INSTRUCTIONS]
;;Four extensions have been introduced into the IA-32 architecture to permit IA-32 processors to perform single-
;;instruction multiple-data (SIMD) operations. These extensions include the MMX technology, SSE extensions, SSE2 
;;extensions, and SSE3 extensions.
;;MMX instructions operate on packed byte, word, doubleword, or quadword integer operands contained in memory, 
;;in MMX registers, and / or in general-purpose registers. 

;[5.4.1 MMX Data Transfer Instructions]
;;;The data transfer instructions move doubleword and quadword operands between MMX registers and between MMX registers and memory.
;MOVD = Move doubleword
;MOVQ = Move quadword

;[5.4.2 MMX Conversion Instructions]
;;;The conversion instructions pack and unpack bytes, words, and doublewords
;PACKSSWB = Pack words into bytes with signed saturation
;PACKSSDW = Pack doublewords into words with signed saturation
;PACKUSWB = Pack words into bytes with unsigned saturation.
;PUNPCKHBW = Unpack high-order bytes
;PUNPCKHWD = Unpack high-order words
;PUNPCKHDQ = Unpack high-order doublewords
;PUNPCKLBW = Unpack low-order bytes
;PUNPCKLWD = Unpack low-order words
;PUNPCKLDQ = Unpack low-order doublewords

;[5.4.3 MMX Packed Arithmetic Instructions]
;;;The packed arithmetic instructions perform packed integer arithmetic on packed byte, word, and doubleword integers.
;PADDB = Add packed byte integers
;PADDW = Add packed word integers
;PADDD = Add packed doubleword integers
;PADDSB = Add packed signed byte integers with signed saturation
;PADDSW = Add packed signed word integers with signed saturation
;PADDUSB = Add packed unsigned byte integers with unsigned saturation
;PADDUSW = Add packed unsigned word integers with unsigned saturation
;PSUBB = Subtract packed byte integers
;PSUBW = Subtract packed word integers
;PSUBD = Subtract packed doubleword integers
;PSUBSB = Subtract packed signed byte integers with signed saturation
;PSUBSW = Subtract packed signed word integers with signed saturation
;PSUBUSB = Subtract packed unsigned byte integers with unsigned saturation
;PSUBUSW = Subtract packed unsigned word integers with unsigned saturation
;PMULHW = Multiply packed signed word integers and store high result
;PMULLW = Multiply packed signed word integers and store low result
;PMADDWD = Multiply and add packed word integers

;[5.4.4 MMX Comparison Instructions]
;;;The compare instructions compare packed bytes, words, or doublewords.
;PCMPEQB = Compare packed bytes for equal
;PCMPEQW = Compare packed words for equal
;PCMPEQD = Compare packed doublewords for equal
;PCMPGTB = Compare packed signed byte integers for greater than
;PCMPGTW = Compare packed signed word integers for greater than
;PCMPGTD = Compare packed signed doubleword integers for greater than

;[5.4.5 MMX Logical Instructions]
;;;The logical instructions perform AND, AND NOT, OR, and XOR operations on quadword operands.
;PAND = Bitwise logical AND
;PANDN = Bitwise logical AND NOT
;POR = Bitwise logical OR
;PXOR = Bitwise logical exclusive OR

;[5.4.6 MMX Shift and Rotate Instructions]
;;;The shift and rotate instructions shift and rotate packed bytes, words, or doublewords, or quadwords in 64-bit operands.
;PSLLW = Shift packed words left logical
;PSLLD = Shift packed doublewords left logical
;PSLLQ = Shift packed quadword left logical
;PSRLW = Shift packed words right logical
;PSRLD = Shift packed doublewords right logical
;PSRLQ = Shift packed quadword right logical
;PSRAW = Shift packed words right arithmetic
;PSRAD = Shift packed doublewords right arithmetic

;[5.4.7 MMX State Management Instructions]
;;;The EMMS instruction clears the MMX state f
;EMMS = Empty MMX state

;[5.5 SSE INSTRUCTIONS]
;;;SSE instructions represent an extension of the SIMD execution model introduced with the MMX technology. 
;;;SSE instructions can only be executed on Intel 64 and IA-32 processors that support SSE extensions. Support for 
;;;these instructions can be detected with the CPUID instruction. 
;;;SSE instructions are divided into four subgroups (note that the first subgroup has subordinate subgroups of its own):
;;;• SIMD single-precision floating-point instructions that operate on the XMM registers
;;;• MXCSR state management instructions
;;;• 64-bit SIMD integer instructions that operate on the MMX registers
;;;• Cacheability control, prefetch, and instruction ordering instructions

;[5.5.1 SSE SIMD Single-Precision Floating-Point Instructions]
;;;These instructions operate on packed and scalar single-precision floating-point values located in XMM registers 
;;;and / or memory. This subgroup is further divided into the following subordinate subgroups: data transfer, packed 
;;;arithmetic, comparison, logical, shuffle and unpack, and conversion instructions.

;[5.5.1.1  SSE Data Transfer Instructions]
;;;SSE data transfer instructions move packed and scalar single-precision floating-point operands between XMM registers and between XMM registers and memory.
;MOVAPS = Move four aligned packed single-precision floating-point values between XMM registers or between and XMM register and memory
;MOVUPS = Move four unaligned packed single-precision floating-point values between XMM registers or between and XMM register and memory
;MOVHPS = Move two packed single-precision floating-point values to an from the high quadword of an XMM register and memory
;MOVHLPS = Move two packed single-precision floating-point values from the high quadword of an XMM register to the low quadword of another XMM register
;MOVLPS = Move two packed single-precision floating-point values to an from the low quadword of an XMM register and memory
;MOVLHPS = Move two packed single-precision floating-point values from the low quadword of an XMM register to the high quadword of another XMM register
;MOVMSKPS = Extract sign mask from four packed single-precision floating-point values
;MOVSS = Move scalar single-precision floating-point value between XMM registers or between an XMM register and memory

;[5.5.1.2  SSE Packed Arithmetic Instructions]
;;;SSE packed arithmetic instructions perform packed and scalar arithmetic operations on packed and scalar single-precision floating-point operands.
;ADDPS = Add packed single-precision floating-point values
;ADDSS = Add scalar single-precision floating-point values
;SUBPS = Subtract packed single-precision floating-point values
;SUBSS = Subtract scalar single-precision floating-point values
;MULPS = Multiply packed single-precision floating-point values
;MULSS = Multiply scalar single-precision floating-point values
;DIVPS = Divide packed single-precision floating-point values
;DIVSS = Divide scalar single-precision floating-point values
;RCPPS = Compute reciprocals of packed single-precision floating-point values
;RCPSS = Compute reciprocal of scalar single-precision floating-point values
;SQRTPS = Compute square roots of packed single-precision floating-point values
;SQRTSS = Compute square root of scalar single-precision floating-point values
;RSQRTPS = Compute reciprocals of square roots of packed single-precision floating-point values
;RSQRTSS = Compute reciprocal of square root of scalar single-precision floating-point values
;MAXPS = Return maximum packed single-precision floating-point values
;MAXSS = Return maximum scalar single-precision floating-point values
;MINPS = Return minimum packed single-precision floating-point values
;MINSS = Return minimum scalar single-precision floating-point values

;[5.5.1.3  SSE Comparison Instructions]
;;;SSE compare instructions compare packed and scalar single-precision floating-point operands.
;CMPPS = Compare packed single-precision floating-point values
;CMPSS = Compare scalar single-precision floating-point values
;COMISS = Perform ordered comparison of scalar single-precision floating-point values and set flags in EFLAGS register
;UCOMISS = Perform unordered comparison of scalar single-precision floating-point values and set flags in EFLAGS register

;[5.5.1.4  SSE Logical Instructions]
;;;SSE logical instructions perform bitwise AND, AND NOT, OR, and XOR operations on packed single-precision floating-point operands.
;ANDPS = Perform bitwise logical AND of packed single-precision floating-point values
;ANDNPS = Perform bitwise logical AND NOT of packed single-precision floating-point values
;ORPS = Perform bitwise logical OR of packed single-precision floating-point values
;XORPS = Perform bitwise logical XOR of packed single-precision floating-point values

;[5.5.1.5  SSE Shuffle and Unpack Instructions]
;;;SSE shuffle and unpack instructions shuffle or interleave single-precision floating-point values in packed single-precision floating-point operands.
;SHUFPS = Shuffles values in packed single-precision floating-point operands
;UNPCKHPS = Unpacks and interleaves the two high-order values from two single-precision floating-point operands
;UNPCKLPS = Unpacks and interleaves the two low-order values from two single-precision floating-point operands

;[5.5.1.6  SSE Conversion Instructions]
;;;SSE conversion instructions convert packed and individual doubleword integers into packed and scalar single-precision floating-point values and vice versa.
;CVTPI2PS = Convert packed doubleword integers to packed single-precision floating-point values
;CVTSI2SS = Convert doubleword integer to scalar single-precision floating-point value
;CVTPS2PI = Convert packed single-precision floating-point values to packed doubleword integers
;CVTTPS2PI = Convert with truncation packed single-precision floating-point values to packed doubleword integers
;CVTSS2SI = Convert a scalar single-precision floating-point value to a doubleword integer
;CVTTSS2SI = Convert with truncation a scalar single-precision floating-point value to a scalar doubleword integer

;[5.5.2 SSE MXCSR State Management Instructions]
;;;MXCSR state management instructions allow saving and restoring the state of the MXCSR control and status register.
;LDMXCSR = Load MXCSR register
;STMXCSR = Save MXCSR register state

;[5.5.3 SSE 64-Bit SIMD Integer Instructions]
;;;These SSE 64-bit SIMD integer instructions perform additional operations on packed bytes, words, or doublewords contained in MMX registers.
;PAVGB = Compute average of packed unsigned byte integers
;PAVGW = Compute average of packed unsigned word integers
;PEXTRW = Extract word
;PINSRW = Insert word
;PMAXUB = Maximum of packed unsigned byte integers
;PMAXSW = Maximum of packed signed word integers
;PMINUB = Minimum of packed unsigned byte integers
;PMINSW = Minimum of packed signed word integers
;PMOVMSKB = Move byte mask
;PMULHUW = Multiply packed unsigned integers and store high result
;PSADBW = Compute sum of absolute differences
;PSHUFW = Shuffle packed integer word in MMX register

;[5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions]
;;;The cacheability control instructions provide control over the caching of non-temporal data when storing data from 
;;;the MMX and XMM registers to memory. The PREFETCHh allows data to be prefetched to a selected cache level. The 
;;;SFENCE instruction controls instruction ordering on store operations.
;MASKMOVQ = Non-temporal store of selected bytes from an MMX register into memory
;MOVNTQ = Non-temporal store of quadword from an MMX register into memory
;MOVNTPS = Non-temporal store of four packed single-precision floating-point values from an XMM register into memory
;PREFETCH = Load 32 or more of bytes from memory to a selected level of the processor’s cache hierarchy
;SFENCE = Serializes store operations

;[5.6 SSE2 INSTRUCTIONS]
;;;SSE2 extensions represent an extension of the SIMD execution model introduced with MMX technology and the 
;;;SSE extensions. SSE2 instructions operate on packed double-precision floating-point operands and on packed 
;;;byte, word, doubleword, and quadword operands located in the XMM registers.
;;;SSE2 instructions can only be executed on Intel 64 and IA-32 processors that support the SSE2 extensions. 
;;;Support for these instructions can be detected with the CPUID instruction.
;;;These instructions are divided into four subgroups (note that the first subgroup is further divided into subordinate subgroups):
;;;• Packed and scalar double-precision floating-point instructions
;;;• Packed single-precision floating-point conversion instructions
;;;• 128-bit SIMD integer instructions
;;;• Cacheability-control and instruction ordering instructions

;[5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions]
;;;SSE2 packed and scalar double-precision floating-point instructions are divided into the following subordinate 
;;;subgroups: data movement, arithmetic, comparison, conversion, logical, and shuffle operations on double-precision floating-point operands. 

;[5.6.1.1  SSE2 Data Movement Instructions]
;;;SSE2 data movement instructions move double-precision floating-point data between XMM registers and between XMM registers and memory.
;MOVAPD = Move two aligned packed double-precision floating-point values between XMM registers or between and XMM register and memory
;MOVUPD = Move two unaligned packed double-precision floating-point values between XMM registers or between and XMM register and memory
;MOVHPD = Move high packed double-precision floating-point value to an from the high quadword of an XMM register and memory
;MOVLPD = Move low packed single-precision floating-point value to an from the low quadword of an XMM register and memory
;MOVMSKPD = Extract sign mask from two packed double-precision floating-point values
;MOVSD = Move scalar double-precision floating-point value between XMM registers or between an XMM register and memory

;[5.6.1.2  SSE2 Packed Arithmetic Instructions]
;;;The arithmetic instructions perform addition, subtraction, multiply, divide, square root, and maximum / minimum 
;;;operations on packed and scalar double-precision floating-point operands.
;ADDPD = Add packed double-precision floating-point values
;ADDSD = Add scalar double precision floating-point values
;SUBPD = Subtract scalar double-precision floating-point values
;SUBSD = Subtract scalar double-precision floating-point values
;MULPD = Multiply packed double-precision floating-point values
;MULSD = Multiply scalar double-precision floating-point values
;DIVPD = Divide packed double-precision floating-point values
;DIVSD = Divide scalar double-precision floating-point values
;SQRTPD = Compute packed square roots of packed double-precision floating-point values
;SQRTSD = Compute scalar square root of scalar double-precision floating-point values
;MAXPD = Return maximum packed double-precision floating-point values
;MAXSD = Return maximum scalar double-precision floating-point values
;MINPD = Return minimum packed double-precision floating-point values
;MINSD = Return minimum scalar double-precision floating-point values

;[5.6.1.3  SSE2 Logical Instructions]
;;;SSE2 logical instructions preform AND, AND NOT, OR, and XOR operations on packed double-precision floating-point values.
;ANDPD = Perform bitwise logical AND of packed double-precision floating-point values
;ANDNPD = Perform bitwise logical AND NOT of packed double-precision floating-point values
;ORPD = Perform bitwise logical OR of packed double-precision floating-point values
;XORPD = Perform bitwise logical XOR of packed double-precision floating-point values

;[5.6.1.4  SSE2 Compare Instructions]
;;;SSE2 compare instructions compare packed and scalar double-precision floating-point values and return the 
;;;results of the comparison either to the destination operand or to the EFLAGS register.
;CMPPD = Compare packed double-precision floating-point values
;CMPSD = Compare scalar double-precision floating-point values
;COMISD = Perform ordered comparison of scalar double-precision floating-point values and set flags in EFLAGS register
;UCOMISD = Perform unordered comparison of scalar double-precision floating-point values and set flags in EFLAGS register.

;[5.6.1.5 SSE2 Shuffle and Unpack Instructions]
;;;SSE2 shuffle and unpack instructions shuffle or interleave double-precision floating-point values in packed double-precision floating-point operands.
;SHUFPD = Shuffles values in packed double-precision floating-point operands
;UNPCKHPD = Unpacks and interleaves the high values from two packed double-precision floating-point operands
;UNPCKLPD = Unpacks and interleaves the low values from two packed double-precision floating-point oper-ands

;[5.6.1.6  SSE2 Conversion Instructions]
;;;SSE2 conversion instructions convert packed and individual doubleword integers into packed and scalar double-
;;;precision floating-point values and vice versa. They also convert between packed and scalar single-precision and 
;;;double-precision floating-point values.
;CVTPD2PI = Convert packed double-precision floating-point values to packed doubleword integers.
;CVTTPD2PI = Convert with truncation packed double-precision floating-point values to packed doubleword integers
;CVTPI2PD = Convert packed doubleword integers to packed double-precision floating-point values
;CVTPD2DQ = Convert packed double-precision floating-point values to packed doubleword integers
;CVTTPD2DQ = Convert with truncation packed double-precision floating-point values to packed doubleword integers
;CVTDQ2PD = Convert packed doubleword integers to packed double-precision floating-point values
;CVTPS2PD = Convert packed single-precision floating-point values to packed double-precision floating-point values
;CVTPD2PS = Convert packed double-precision floating-point values to packed single-precision floating-point values
;CVTSS2SD = Convert scalar single-precision floating-point values to scalar double-precision floating-point values
;CVTSD2SS = Convert scalar double-precision floating-point values to scalar single-precision floating-point values
;CVTSD2SI = Convert scalar double-precision floating-point values to a doubleword integer
;CVTTSD2SI = Convert with truncation scalar double-precision floating-point values to scalar doubleword integers
;CVTSI2SD = Convert doubleword integer to scalar double-precision floating-point value

;[5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions]
;;;SSE2 packed single-precision floating-point instructions perform conversion operations on single-precision 
;;;floating-point and integer operands. These instructions represent enhancements to the SSE single-precision 
;;;floating-point instructions.
;CVTDQ2PS = Convert packed doubleword integers to packed single-precision floating-point values
;CVTPS2DQ = Convert packed single-precision floating-point values to packed doubleword integers
;CVTTPS2DQ = Convert with truncation packed single-precision floating-point values to packed doubleword integers

;[5.6.3 SSE2 128-Bit SIMD Integer Instructions]
;;;SSE2 SIMD integer instructions perform additional operations on packed words, doublewords, and quadwords contained in XMM and MMX registers.
;MOVDQA = Move aligned double quadword.
;MOVDQU = Move unaligned double quadword
;MOVQ2DQ = Move quadword integer from MMX to XMM registers
;MOVDQ2Q = Move quadword integer from XMM to MMX registers
;PMULUDQ = Multiply packed unsigned doubleword integers
;PADDQ = Add packed quadword integers
;PSUBQ = Subtract packed quadword integers
;PSHUFLW = Shuffle packed low words
;PSHUFHW = Shuffle packed high words
;PSHUFD = Shuffle packed doublewords
;PSLLDQ = Shift double quadword left logical
;PSRLDQ = Shift double quadword right logical
;PUNPCKHQDQ = Unpack high quadwords
;PUNPCKLQDQ = Unpack low quadwords

;[5.6.4 SSE2 Cacheability Control and Ordering Instructions]
;;;SSE2 cacheability control instructions provide additional operations for caching of non-temporal data when storing 
;;;data from XMM registers to memory. LFENCE and MFENCE provide additional control of instruction ordering on 
;;;store operations.
;CLFLUSH = Flushes and invalidates a memory operand and its associated cache line from all levels of the processor’s cache hierarchy
;LFENCE = Serializes load operations
;MFENCE = Serializes load and store operations
;PAUSE = Improves the performance of “spin-wait loops”
;MASKMOVDQU = Non-temporal store of selected bytes from an XMM register into memory
;MOVNTPD = Non-temporal store of two packed double-precision floating-point values from an XMM register into memory
;MOVNTDQ = Non-temporal store of double quadword from an XMM register into memory
;MOVNTI = Non-temporal store of a doubleword from a general-purpose register into memory

;[5.7 SSE3 INSTRUCTIONS]
;;;The SSE3 extensions offers 13 instructions that accelerate performance of Streaming SIMD Extensions technology, 
;;;Streaming SIMD Extensions 2 technology, and x87-FP math capabilities. These instructions can be grouped into the 
;;;following categories:
;;;• One x87FPU instruction used in integer conversion
;;;• One SIMD integer instruction that addresses unaligned data loads
;;;• Two SIMD floating-point packed ADD / SUB instructions
;;;• Four SIMD floating-point horizontal ADD / SUB instructions
;;;• Three SIMD floating-point LOAD / MOVE / DUPLICATE instructions
;;;• Two thread synchronization instructions

;[5.7.1 SSE3 x87-FP Integer Conversion Instruction]
;FISTTP = Behaves like the FISTP instruction but uses truncation, irrespective of the rounding mode specified in the floating-point control word (FCW)

;[5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction]
;LDDQU = Special 128-bit unaligned load designed to avoid cache line splits

;[5.7.3 SSE3 SIMD Floating-Point Packed ADD / SUB Instructions]
;ADDSUBPS = Performs single-precision addition on the second and fourth pairs of 32-bit data elements within the operands;; single-precision subtraction on the first and third pairs
;ADDSUBPD = Performs double-precision addition on the second pair of quadwords, and double-precision subtraction on the first pair

;[5.7.4 SSE3 SIMD Floating-Point Horizontal ADD / SUB Instructions]
;HADDPS = Performs a single-precision addition on contiguous data elements. The first data element of the result is obtained by adding the first and second elements of the first operand;; the second element by adding the third and fourth elements of the first operand;; the third by adding the first and second elements of the second operand;; and the fourth by adding the third and fourth elements of the second operand.
;HSUBPS = Performs a single-precision subtraction on contiguous data elements. The first data element of the result is obtained by subtracting the second element of the first operand from the first element of the first operand;; the second element by subtracting the fourth element of the first operand from the third element of the first operand;; the third by subtracting the second element of the second operand from the first element of the second operand;; and the fourth by subtracting the fourth element of the second operand from the third element of the second operand.
;HADDPD = Performs a double-precision addition on contiguous data elements. The first data element of the result is obtained by adding the first and second elements of the first operand;; the second element by adding the first and second elements of the second operand.
;HSUBPD = Performs a double-precision subtraction on contiguous data elements. The first data element of the result is obtained by subtracting the second element of the first operand from the first element of the first operand;; the second element by subtracting the second element of the second operand from the first element of the second operand.

;[5.7.5 SSE3 SIMD Floating-Point LOAD / MOVE / DUPLICATE Instructions]
;MOVSHDUP = Loads / moves 128 bits;; duplicating the second and fourth 32-bit data elements
;MOVSLDUP = Loads / moves 128 bits;; duplicating the first and third 32-bit data elements
;MOVDDUP = Loads / moves 64 bits (bits[63:0] if the source is a register) and returns the same 64 bits in both the lower and upper halves of the 128-bit result register;; duplicates the 64 bits from the source

;[5.7.6 SSE3 Agent Synchronization Instructions]
;MONITOR = Sets up an address range used to monitor write-back stores 
;MWAIT = Enables a logical processor to enter into an optimized state while waiting for a write-back store to the address range set up by the MONITOR instruction

;[5.8 SUPPLEMENTAL STREAMING SIMD EXTENSIONS 3 (SSSE3) INSTRUCTIONS]
;;;SSSE3 provide 32 instructions (represented by 14 mnemonics) to accelerate computations on packed integers. These include:
;;;• Twelve instructions that perform horizontal addition or subtraction operations.
;;;• Six instructions that evaluate absolute values.
;;;• Two instructions that perform multiply and add operations and speed up the evaluation of dot products.
;;;• Two instructions that accelerate packed-integer multiply operations and produce integer values with scaling.
;;;• Two instructions that perform a byte-wise, in-place shuffle according to the second shuffle control operand.
;;;• Six instructions that negate packed integers in the destination operand if the signs of the corresponding element in the source operand is less than zero.
;;;• Two instructions that align data from the composite of two operands.

;[5.8.1 Horizontal Addition / Subtraction]
;PHADDW = Adds two adjacent, signed 16-bit integers horizontally from the source and destination operands and packs the signed 16-bit results to the destination operand.
;PHADDSW = Adds two adjacent, signed 16-bit integers horizontally from the source and destination operands and packs the signed, saturated 16-bit results to the destination operand.
;PHADDD = Adds two adjacent, signed 32-bit integers horizontally from the source and destination operands and packs the signed 32-bit results to the destination operand.
;PHSUBW = Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and desti-nation operands. The signed 16-bit results are packed and written to the destination operand.
;PHSUBSW = Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by subtracting the most significant word from the least significant word of each pair in the source and desti-nation operands. The signed, saturated 16-bit results are packed and written to the destina-tion operand.
;PHSUBD = Performs horizontal subtraction on each adjacent pair of 32-bit signed integers by subtracting the most significant doubleword from the least significant double word of each pair in the source and destination operands. The signed 32-bit results are packed and written to the destination operand.

;[5.8.2 Packed Absolute Values]
;PABSB = Computes the absolute value of each signed byte data element.
;PABSW = Computes the absolute value of each signed 16-bit data element.
;PABSD = Computes the absolute value of each signed 32-bit data element. 

;[5.8.5 Packed Shuffle Bytes]
;PSHUFB = Permutes each byte in place, according to a shuffle control mask. The least significant three or four bits of each shuffle control byte of the control mask form the shuffle index. The shuffle mask is unaffected. If the most significant bit (bit 7) of a shuffle control byte is set, the constant zero is written in the result byte.

;[5.8.6 Packed Sign]
;PSIGNB = Negates each signed integer element of the destination operand if the sign of the corresponding data element in the source operand is less than zero.
;PSIGNW = Negates each signed integer element of the destination operand if the sign of the corresponding data element in the source operand is less than zero.
;PSIGND = Negates each signed integer element of the destination operand if the sign of the corresponding data element in the source operand is less than zero.

;[5.8.7 Packed Align Right]
;PALIGNR = Source operand is appended after the destination operand forming an intermediate value of twice the width of an operand. The result is extracted from the intermediate value into the destination operand by selecting the 128 bit or 64 bit value that are right-aligned to the byte offset specified by the immediate value.

;[5.9 SSE4 INSTRUCTIONS]
;;;Intel® Streaming SIMD Extensions 4 (SSE4) introduces 54 new instructions. 47 of the SSE4 instructions are 
;;;referred to as SSE4.1 in this document, 7 new SSE4 instructions are referred to as SSE4.2. 
;;;SSE4.1 is targeted to improve the performance of media, imaging, and 3D workloads. SSE4.1 adds instructions 
;;;that improve compiler vectorization and significantly increase support for packed dword computation. The tech-
;;;nology also provides a hint that can improve memory throughput when reading from uncacheable WC memory type.
;;;The 47 SSE4.1 instructions include:
;;;• Two instructions perform packed dword multiplies.
;;;• Two instructions perform floating-point dot products with input / output selects.
;;;• One instruction performs a load with a streaming hint.
;;;• Six instructions simplify packed blending.
;;;• Eight instructions expand support for packed integer MIN / MAX.
;;;• Four instructions support floating-point round with selectable rounding mode and precision exception override.
;;;• Seven instructions improve data insertion and extractions from XMM registers
;;;• Twelve instructions improve packed integer format conversions (sign and zero extensions).
;;;• One instruction improves SAD (sum absolute difference) generation for small block sizes.
;;;• One instruction aids horizontal searching operations.
;;;• One instruction improves masked comparisons.
;;;• One instruction adds qword packed equality comparisons.
;;;• One instruction adds dword packing with unsigned saturation.
;;;The SSE4.2 instructions operating on XMM registers include:
;;;• String and text processing that can take advantage of single-instruction multiple-data programming techniques.
;;;• A SIMD integer instruction that enhances the capability of the 128-bit integer SIMD capability in SSE4.1.

;[5.10 SSE4.1 INSTRUCTIONS]
;;;SSE4.1 instructions can use an XMM register as a source or destination. Programming SSE4.1 is similar to 
;;;programming 128-bit Integer SIMD and floating-point SIMD instructions in SSE / SSE2 / SSE3 / SSSE3. SSE4.1 does 
;;;not provide any 64-bit integer SIMD instructions operating on MMX registers. 

;[5.10.1 Dword Multiply Instructions ]
;PMULLD = Returns four lower 32-bits of the 64-bit results of signed 32-bit integer 

;[5.10.2 Floating-Point Dot Product Instructions]
;DPPD = Perform double-precision dot product for up to 2 elements and broadcast.
;DPPS = Perform single-precision dot products for up to 4 elements and broadcast

;[5.10.3 Streaming Load Hint Instruction]
;MOVNTDQA = Provides a non-temporal hint that can cause adjacent 16-byte items within an aligned 64-byte region (a streaming line) to be fetched and held in a small set of temporary buffers (“streaming load buffers”). Subsequent streaming loads to other aligned 16-byte items in the same streaming line may be supplied from the streaming load buffer and can improve throughput.

;[5.10.4 Packed Blending Instructions]
;BLENDPD = Conditionally copies specified double-precision floating-point data elements in the source operand to the corresponding data elements in the destination, using an immediate byte control. 
;BLENDPS = Conditionally copies specified single-precision floating-point data elements in the source operand to the corresponding data elements in the destination, using an immediate byte control.
;BLENDVPD = Conditionally copies specified double-precision floating-point data elements in the source operand to the corresponding data elements in the destination, using an implied mask. 
;BLENDVPS = Conditionally copies specified single-precision floating-point data elements in the source operand to the corresponding data elements in the destination, using an implied mask. 
;PBLENDVB = Conditionally copies specified byte elements in the source operand to the corresponding elements in the destination, using an implied mask.
;PBLENDW = Conditionally copies specified word elements in the source operand to the corresponding elements in the destination, using an immediate byte control.

;[5.10.5 Packed Integer MIN / MAX Instructions ]
;PMINUW = Compare packed unsigned word integers.
;PMINUD = Compare packed unsigned dword integers.
;PMINSB = Compare packed signed byte integers.
;PMINSD = Compare packed signed dword integers.
;PMAXUW = Compare packed unsigned word integers.
;PMAXUD = Compare packed unsigned dword integers.
;PMAXSB = Compare packed signed byte integers.
;PMAXSD = Compare packed signed dword integers.

;[5.10.6 Floating-Point Round Instructions with Selectable Rounding Mode]
;ROUNDPS = Round packed single precision floating-point values into integer values and return rounded floating-point values.
;ROUNDPD = Round packed double precision floating-point values into integer values and return rounded floating-point values. 
;ROUNDSS = Round the low packed single precision floating-point value into an integer value and return a rounded floating-point value.
;ROUNDSD = Round the low packed double precision floating-point value into an integer value and return a rounded floating-point value.

;[5.10.7 Insertion and Extractions from XMM Registers]
;EXTRACTPS = Extracts a single-precision floating-point value from a specified offset in an XMM register and stores the result to memory or a general-purpose register
;INSERTPS = Inserts a single-precision floating-point value from either a 32-bit memory location or selected from a specified offset in an XMM register to a specified offset in the destination XMM register. In addition, INSERTPS allows zeroing out selected data elements in the destination, using a mask.
;PINSRB = Insert a byte value from a register or memory into an XMM register 
;PINSRD = Insert a dword value from 32-bit register or memory into an XMM register
;PINSRQ = Insert a qword value from 64-bit register or memory into an XMM register
;PEXTRB = Extract a byte from an XMM register and insert the value into a general-purpose register or memory
;PEXTRW = Extract a word from an XMM register and insert the value into a general-purpose register or memory
;PEXTRD = Extract a dword from an XMM register and insert the value into a general-purpose register or memory
;PEXTRQ = Extract a qword from an XMM register and insert the value into a general-purpose register or memory

;[5.10.8 Packed Integer Format Conversions]
;PMOVSXBW = Sign extend the lower 8-bit integer of each packed word element into packed signed word integers. 
;PMOVZXBW = Zero extend the lower 8-bit integer of each packed word element into packed signed word integers.
;PMOVSXBD = Sign extend the lower 8-bit integer of each packed dword element into packed signed dword integers.
;PMOVZXBD = Zero extend the lower 8-bit integer of each packed dword element into packed signed dword integers.
;PMOVSXWD = Sign extend the lower 16-bit integer of each packed dword element into packed signed dword integers.
;PMOVZXWD = Zero extend the lower 16-bit integer of each packed dword element into packed signed dword integers..
;PMOVSXBQ = Sign extend the lower 8-bit integer of each packed qword element into packed signed qword integers.
;PMOVZXBQ = Zero extend the lower 8-bit integer of each packed qword element into packed signed qword integers.
;PMOVSXWQ = Sign extend the lower 16-bit integer of each packed qword element into packed signed qword integers.
;PMOVZXWQ = Zero extend the lower 16-bit integer of each packed qword element into packed signed qword integers.
;PMOVSXDQ = Sign extend the lower 32-bit integer of each packed qword element into packed signed qword integers.
;PMOVZXDQ = Zero extend the lower 32-bit integer of each packed qword element into packed signed qword integers.

;[5.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks]
;MPSADBW = Performs eight 4-byte wide Sum of Absolute Differences operations to produce eight word integers. 

;[5.10.10 Horizontal Search]
;PHMINPOSUW = Finds the value and location of the minimum unsigned word from one of 8 horizontally packed unsigned words.  The resulting value and location (offset within the source) are packed into the low dword of the destination XMM register.

;[5.10.11 Packed Test]
;PTEST = Performs a logical AND between the destination with this mask and sets the ZF flag if the result is zero. The CF flag (zero for TEST) is set if the inverted mask AND’d with the destination is all zero

;[5.10.12 Packed Qword Equality Comparisons]
;PCMPEQQ = 128-bit packed qword equality test 

;[5.10.13 Dword Packing With Unsigned Saturation]
;PACKUSDW = PACKUSDW packs dword to word with unsigned saturation

;[5.11 SSE4.2 INSTRUCTION SET]
;;;Five of the SSE4.2 instructions operate on XMM register as a source or destination. These include four text / string 
;;;processing instructions and one packed quadword compare SIMD instruction. Programming these five SSE4.2 
;;;instructions is similar to programming 128-bit Integer SIMD in SSE2 / SSSE3. SSE4.2 does not provide any 64-bit 
;;;integer SIMD instructions. 
;;;CRC32 operates on general-purpose registers and is summarized in Section 5.1.6. The sections that follow summa-
;;;rize each subgroup.

;[5.11.1 String and Text Processing Instructions]
;PCMPESTRI = Packed compare explicit-length strings, return index in ECX / RCX
;PCMPESTRM = Packed compare explicit-length strings, return mask in XMM0
;PCMPISTRI = Packed compare implicit-length strings, return index in ECX / RCX

;[5.11.2 Packed Comparison SIMD integer Instruction]
;PCMPGTQ = Performs logical compare of greater-than on packed integer quadwords.
;;;AVX EXTENSION
;VPCMPGTQ = Performs logical compare of greater-than on packed integer quadwords.

;[5.12 AESNI AND PCLMULQDQ]
;;;Six AESNI instructions operate on XMM registers to provide accelerated primitives for block encryption / decryption 
;;;using Advanced Encryption Standard (FIPS-197). The PCLMULQDQ instruction performs carry-less multiplication 
;;;for two binary numbers up to 64-bit wide. 
;AESDEC = Perform an AES decryption round using an 128-bit state and a round key
;AESDECLAST = Perform the last AES decryption round using an 128-bit state and a round key
;AESENC = Perform an AES encryption round using an 128-bit state and a round key
;AESENCLAST = Perform the last AES encryption round using an 128-bit state and a round key
;AESIMC = Perform an inverse mix column transformation primitive
;AESKEYGENASSIST = Assist the creation of round keys with a key expansion schedule
;PCLMULQDQ = Perform carryless multiplication of two 64-bit numbers

;[5.13 INTEL® ADVANCED VECTOR EXTENSIONS (INTEL® AVX)]
;;;Intel® Advanced Vector Extensions (AVX) promotes legacy 128-bit SIMD instruction sets that operate on XMM 
;;;register set to use a “vector extension“ (VEX) prefix and operates on 256-bit vector registers (YMM). Almost all 
;;;prior generations of 128-bit SIMD instructions that operates on XMM (but not on MMX registers) are promoted to 
;;;support three-operand syntax with VEX-128 encoding.
;;;VEX-prefix encoded AVX instructions support 256-bit and 128-bit floating-point operations by extending the legacy 
;;;128-bit SIMD floating-point instructions to support three-operand syntax. 

;[5.14 16-BIT FLOATING-POINT CONVERSION]
;;;Conversion between single-precision floating-point (32-bit) and half-precision FP (16-bit) data are provided by VCVTPS2PH, VCVTPH2PS:
;VCVTPH2PS = Convert eight / four data element containing 16-bit floating-point data into eight / four single-precision floating-point data.
;VCVTPS2PH = Convert eight / four data element containing single-precision floating-point data into eight / four 16-bit floating-point data.

;[5.15 FUSED-MULTIPLY-ADD (FMA)]
;;;FMA extensions enhances Intel AVX with high-throughput, arithmetic capabilities covering fused multiply-add, 
;;;fused multiply-subtract, fused multiply add / subtract interleave, signed-reversed multiply on fused multiply-add 
;;;and multiply-subtract. FMA extensions provide 36 256-bit floating-point instructions to perform computation on 
;;;256-bit vectors and additional 128-bit and scalar FMA instructions.

;[5.16 INTEL® ADVANCED VECTOR EXTENSIONS 2 (INTEL® AVX2)]
;;;Intel® AVX2 extends Intel AVX by promoting most of the 128-bit SIMD integer instructions with 256-bit numeric 
;;;processing capabilities. Intel AVX2 instructions follow the same programming model as AVX instructions. 
;;;In addition, AVX2 provide enhanced functionalities for broadcast / permute operations on data elements, vector 
;;;shift instructions with variable-shift count per data element, and instructions to fetch non-contiguous data 
;;;elements from memory.


;; #######################################################################################################################
;; Системные функции - пока что не переведены
;; #######################################################################################################################


;[5.17 INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS (TSX)]
;XABORT = Abort an RTM transaction execution
;XACQUIRE = Prefix hint to the beginning of an HLE transaction region
;XRELEASE = Prefix hint to the end of an HLE transaction region
;XBEGIN = Transaction begin of an RTM transaction region
;XEND = Transaction end of an RTM transaction region
;XTEST = Test if executing in a transactional region

;[5.18 SYSTEM INSTRUCTIONS]
;;;The following system instructions are used to control those functions of the processor that are provided to support for operating systems and executives.
;CLAC = Clear AC Flag in EFLAGS register
;STAC = Set AC Flag in EFLAGS register
;LGDT = Load global descriptor table (GDT) register
;SGDT = Store global descriptor table (GDT) register
;LLDT = Load local descriptor table (LDT) register
;SLDT = Store local descriptor table (LDT) register
;LTR = Load task register
;STR = Store task register
;LIDT = Load interrupt descriptor table (IDT) register
;SIDT = Store interrupt descriptor table (IDT) register
;LMSW = Load machine status word
;SMSW = Store machine status word
;CLTS = Clear the task-switched flag
;ARPL = Adjust requested privilege level
;LAR = Load access rights
;LSL = Load segment limit
;VERR = Verify segment for reading
;VERW = Verify segment for writing
;MOV = Load and store debug registers
;INVD = Invalidate cache, no writeback
;WBINVD = Invalidate cache, with writeback
;INVLPG = Invalidate TLB Entry
;INVPCID = Invalidate Process-Context Identifier
;LOCK = Lock Bus
;HLT = Halt processor
;RSM = Return from system management mode (SMM)
;RDMSR = Read model-specific register
;WRMSR = Write model-specific register
;RDPMC = Read performance monitoring counters
;RDTSC = Read time stamp counter
;RDTSCP = Read time stamp counter and processor ID
;SYSENTER = Fast System Call, transfers to a flat protected mode kernel at CPL =  0
;SYSEXIT = Fast System Call, transfers to a flat protected mode kernel at CPL =  3
;XSAVE = Save processor extended states to memory
;XSAVEOPT = Save processor extended states to memory, optimized
;XRSTOR = Restore processor extended states from memory
;XGETBV = Reads the state of an extended control register
;XSETBV = Writes the state of an extended control register
;RDFSBASE = Reads from FS base address at any privilege level
;RDGSBASE = Reads from GS base address at any privilege level
;WRFSBASE = Writes to FS base address at any privilege level
;WRGSBASE = Writes to GS base address at any privilege level

